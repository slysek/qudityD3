Index: QuditsOnQubits/QuditsOnQubits/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom qiskit.circuit import QuantumCircuit\r\nfrom qiskit.quantum_info import Statevector, Operator\r\nfrom qiskit.synthesis import TwoQubitWeylDecomposition\r\nfrom qiskit.circuit.library import UnitaryGate\r\nfrom qiskit_ibm_runtime.fake_provider import FakeBrisbane\r\nfrom qiskit_ibm_runtime.fake_provider import FakeTorino\r\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\r\nfrom qiskit_ibm_runtime import SamplerV2\r\nfrom qiskit_aer import AerSimulator\r\nfrom qiskit.visualization import plot_histogram\r\nfrom qiskit.quantum_info import hellinger_fidelity\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom QuditsOnQubits.ghz_creator import create_basic_ghz\r\nfrom QuditsOnQubits.ghz_creator import create_graph_ghz\r\n\r\nclass QuditsOnQubits:\r\n    def __init__(self, graph=None):\r\n        if graph is None:\r\n            self.circuit = create_basic_ghz()\r\n            self.statBasic = Statevector.from_instruction(self.circuit[0]).probabilities_dict()\r\n        else:\r\n            self.circuit = create_graph_ghz(graph)\r\n            self.statBasic = Statevector.from_instruction(self.circuit).probabilities_dict()\r\n\r\n        self.backend = None\r\n        self.transpiled = None\r\n        self.name = None\r\n\r\n        self.statTorino = None\r\n        self.statBrisbane = None\r\n\r\n    def brisbane(self):\r\n        backend_brisbane = FakeBrisbane()\r\n        self.backend = backend_brisbane\r\n        self.name = \"Brisbane\"\r\n\r\n\r\n        target_brisbane = backend_brisbane.target\r\n        pass_manager_brisbane = generate_preset_pass_manager(\r\n            optimization_level=3, target=target_brisbane\r\n        )\r\n\r\n        tempCirc = self.circuit[0].copy()\r\n        tempCirc.measure_all()\r\n        transpiled_brisbane = pass_manager_brisbane.run(tempCirc)\r\n        self.transpiled = transpiled_brisbane\r\n\r\n\r\n        aer = AerSimulator.from_backend(backend_brisbane)\r\n        sampler = SamplerV2(aer)\r\n        job = sampler.run([transpiled_brisbane])\r\n        pub_result = job.result()[0]\r\n        counts = pub_result.data.meas.get_counts()\r\n\r\n\r\n        self.statBrisbane = counts\r\n\r\n        return transpiled_brisbane\r\n\r\n\r\n    def torino(self):\r\n\r\n        backend_torino = FakeTorino()\r\n        self.backend = backend_torino\r\n        self.name = \"Torino\"\r\n\r\n        target_torino = backend_torino.target\r\n        pass_manager_torino = generate_preset_pass_manager(\r\n            optimization_level=3, target=target_torino\r\n        )\r\n        tempCirc = self.circuit[0].copy()\r\n        tempCirc.measure_all()\r\n        transpiled_torino = pass_manager_torino.run(tempCirc)\r\n        self.transpiled = transpiled_torino\r\n\r\n\r\n        aer = AerSimulator.from_backend(backend_torino)\r\n        sampler = SamplerV2(aer)\r\n        job = sampler.run([transpiled_torino])\r\n        pub_result = job.result()[0]\r\n        counts = pub_result.data.meas.get_counts()\r\n\r\n        self.statTorino = counts\r\n\r\n        return transpiled_torino\r\n\r\n    def distrb(self):\r\n        if self.backend is None:\r\n            circ_temp = self.circuit.copy()\r\n            circ_temp.remove_final_measurements()\r\n            d = Statevector.from_instruction(circ_temp).probabilities_dict()\r\n            self.statBasic = d\r\n            plot_histogram(d, figsize=(30,10))\r\n        else:\r\n            aer = AerSimulator.from_backend(self.backend)\r\n            sampler = SamplerV2(aer)\r\n            job = sampler.run([self.transpiled])\r\n            pub_result = job.result()[0]\r\n            counts = pub_result.data.meas.get_counts()\r\n            if self.name == \"Brisbane\":\r\n                self.statBrisbane = counts\r\n            elif self.name == \"Torino\":\r\n                self.statTorino = counts\r\n            plot_histogram(counts, figsize=(30, 10))\r\n\r\n    def fidelity(self, backend_name):\r\n        if backend_name == \"Brisbane\":\r\n            if self.statBrisbane is None:\r\n                raise ValueError(\"First use .brisbane() to count fidelity.\")\r\n            fid = hellinger_fidelity(self.statBasic, self.statBrisbane)\r\n\r\n        elif backend_name == \"Torino\":\r\n            if self.statTorino is None:\r\n                raise ValueError(\"First use .torino() to count fidelity.\")\r\n            fid = hellinger_fidelity(self.statBasic, self.statTorino)\r\n\r\n        else:\r\n            raise ValueError(\"Unknown backend. Use \\\"Brisbane\\\" or \\\"Torino\\\".\")\r\n\r\n        return fid
===================================================================
diff --git a/QuditsOnQubits/QuditsOnQubits/main.py b/QuditsOnQubits/QuditsOnQubits/main.py
--- a/QuditsOnQubits/QuditsOnQubits/main.py	(revision 090da3ca4086661a8c49bfd7f5ed2e3c83e65783)
+++ b/QuditsOnQubits/QuditsOnQubits/main.py	(date 1740834373125)
@@ -1,8 +1,4 @@
-import numpy as np
-from qiskit.circuit import QuantumCircuit
-from qiskit.quantum_info import Statevector, Operator
-from qiskit.synthesis import TwoQubitWeylDecomposition
-from qiskit.circuit.library import UnitaryGate
+from qiskit.quantum_info import Statevector
 from qiskit_ibm_runtime.fake_provider import FakeBrisbane
 from qiskit_ibm_runtime.fake_provider import FakeTorino
 from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
@@ -10,7 +6,6 @@
 from qiskit_aer import AerSimulator
 from qiskit.visualization import plot_histogram
 from qiskit.quantum_info import hellinger_fidelity
-import matplotlib.pyplot as plt
 
 from QuditsOnQubits.ghz_creator import create_basic_ghz
 from QuditsOnQubits.ghz_creator import create_graph_ghz
